// Generated by CoffeeScript 1.4.0
(function() {
  var Block, Liquid, util, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Liquid = require("../liquid");

  _ = require("underscore")._;

  util = require("util");

  module.exports = Block = (function(_super) {

    __extends(Block, _super);

    function Block() {
      return Block.__super__.constructor.apply(this, arguments);
    }

    Block.IsTag = RegExp("^" + Liquid.TagStart.source);

    Block.IsVariable = RegExp("^" + Liquid.VariableStart.source);

    Block.FullToken = RegExp("^" + Liquid.TagStart.source + "\\s*(\\w+)\\s*(.*)?" + Liquid.TagEnd.source + "$");

    Block.ContentOfVariable = RegExp("^" + Liquid.VariableStart.source + "(.*)" + Liquid.VariableEnd.source + "$");

    Block.prototype.parse = function(tokens) {
      var match, tag, token;
      this.nodelist || (this.nodelist = []);
      while (this.nodelist.length > 0) {
        this.nodelist.pop();
      }
      while (tokens.length > 0) {
        token = tokens.shift();
        if (Block.IsTag.test(token)) {
          if (match = Block.FullToken.exec(token)) {
            if (this.blockDelimiter() === match[1]) {
              this.endTag();
              return;
            }
            if (tag = Liquid.Template.tags[match[1]]) {
              this.nodelist.push(new tag(match[1], match[2], tokens, this.template));
            } else {
              this.unknownTag(match[1], match[2], tokens);
            }
          } else {
            throw new Liquid.SyntaxError("Tag '" + token + "' was not properly terminated with regexp: " + Liquid.TagEnd.inspect);
          }
        } else if (Block.IsVariable.test(token)) {
          this.nodelist.push(this.createVariable(token));
        } else if (token === '') {

        } else {
          this.nodelist.push(token);
        }
      }
      return this.assertMissingDelimitation();
    };

    Block.prototype.endTag = function() {};

    Block.prototype.unknownTag = function(tag, params, tokens) {
      switch (tag) {
        case 'else':
          throw new Liquid.SyntaxError("" + (this.blockName()) + " tag does not expect else tag");
          break;
        case 'end':
          throw new Liquid.SyntaxError("'end' is not a valid delimiter for " + (this.blockName()) + " tags. use " + (this.blockDelimiter()));
          break;
        default:
          throw new Liquid.SyntaxError("Unknown tag '" + tag + "'");
      }
    };

    Block.prototype.blockDelimiter = function() {
      return "end" + (this.blockName());
    };

    Block.prototype.blockName = function() {
      return this.tagName;
    };

    Block.prototype.createVariable = function(token) {
      var match, _ref;
      match = (_ref = Liquid.Block.ContentOfVariable.exec(token)) != null ? _ref[1] : void 0;
      if (match) {
        return new Liquid.Variable(match);
      }
      throw new Liquid.SyntaxError("Variable '" + this.token + "' was not properly terminated with regexp: " + Liquid.Block.VariableEnd.inspect);
    };

    Block.prototype.render = function(context) {
      return this.renderAll(this.nodelist, context);
    };

    Block.prototype.assertMissingDelimitation = function() {
      throw new Liquid.SyntaxError("" + (this.blockName()) + " tag was never closed");
    };

    Block.prototype.renderAll = function(list, context) {
      return Liquid.async.map(list, function(token) {
        try {
          if (token.render) {
            return token.render(context);
          } else {
            return token;
          }
        } catch (e) {
          context.handleError(e);
          throw e;
        }
      }).then(function(result) {
        return result.join("");
      });
    };

    return Block;

  })(require("./tag"));

}).call(this);
