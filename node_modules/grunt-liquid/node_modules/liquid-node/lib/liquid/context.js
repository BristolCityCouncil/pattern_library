// Generated by CoffeeScript 1.4.0
(function() {
  var Context, Liquid, Q, _,
    __slice = [].slice;

  Liquid = require("../liquid");

  _ = require("underscore")._;

  Q = require("q");

  module.exports = Context = (function() {

    function Context(environments, outerScope, registers, rethrowErrors) {
      if (environments == null) {
        environments = {};
      }
      if (outerScope == null) {
        outerScope = {};
      }
      if (registers == null) {
        registers = {};
      }
      if (rethrowErrors == null) {
        rethrowErrors = false;
      }
      this.environments = _.flatten([environments]);
      this.scopes = [outerScope || {}];
      this.registers = registers;
      this.errors = [];
      this.rethrowErrors = rethrowErrors;
      this.strainer = Liquid.Strainer.create(this);
      this.squashInstanceAssignsWithEnvironments();
    }

    Context.prototype.addFilters = function(filters) {
      var _this = this;
      filters = _([filters]).chain().flatten().compact().value();
      return filters.forEach(function(filter) {
        if (!(filter instanceof Object)) {
          throw new Error("Expected Object but got: " + (typeof filter));
        }
        return _.extend(_this.strainer, filter);
      });
    };

    Context.prototype.handleError = function(e) {
      this.errors.push(e);
      if (this.rethrowErrors) {
        throw e;
      }
      if (e instanceof Liquid.SyntaxError) {
        return "Liquid syntax error: " + e.message;
      } else {
        return "Liquid error: " + e.message;
      }
    };

    Context.prototype.invoke = function() {
      var args, f, method;
      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.strainer[method] != null) {
        f = this.strainer[method];
        return f.apply(this.strainer, args);
      } else {
        return args != null ? args[0] : void 0;
      }
    };

    Context.prototype.push = function(newScope) {
      if (newScope == null) {
        newScope = {};
      }
      Liquid.log("SCOPE PUSH");
      this.scopes.unshift(newScope);
      if (this.scopes.length > 100) {
        throw new Error("Nesting too deep");
      }
    };

    Context.prototype.merge = function(newScope) {
      if (newScope == null) {
        newScope = {};
      }
      return _(this.scopes[0]).extend(newScope);
    };

    Context.prototype.pop = function() {
      Liquid.log("SCOPE POP");
      if (this.scopes.length <= 1) {
        throw new Error("ContextError");
      }
      return this.scopes.shift();
    };

    Context.prototype.lastScope = function() {
      return this.scopes[this.scopes.length - 1];
    };

    Context.prototype.stack = function(newScope, f) {
      var popLater, result,
        _this = this;
      if (newScope == null) {
        newScope = {};
      }
      popLater = false;
      try {
        if (arguments.length < 2) {
          f = newScope;
          newScope = {};
        }
        this.push(newScope);
        result = f();
        if (Q.isPromise(result)) {
          popLater = true;
          result.nodeify(function() {
            return _this.pop();
          });
        }
        return result;
      } finally {
        if (!popLater) {
          this.pop();
        }
      }
    };

    Context.prototype.clearInstanceAssigns = function() {
      return this.scopes[0] = {};
    };

    Context.prototype.set = function(key, value) {
      Liquid.log("[SET] %s %j", key, value);
      return this.scopes[0][key] = value;
    };

    Context.prototype.get = function(key) {
      var value;
      value = this.resolve(key);
      Liquid.log("[GET] %s %j", key, value);
      return value;
    };

    Context.prototype.hasKey = function(key) {
      return !!this.resolve(key);
    };

    Context.Literals = {
      'null': null,
      'nil': null,
      '': null,
      'true': true,
      'false': false,
      'empty': function(v) {
        return !v || v.length === 0;
      },
      'blank': function(v) {
        return !v || v.length === 0;
      }
    };

    Context.prototype.resolve = function(key) {
      var hi, lo, match;
      if (_(Liquid.Context.Literals).keys().indexOf(key) >= 0) {
        return Liquid.Context.Literals[key];
      } else {
        if (match = /^'(.*)'$/.exec(key)) {
          return match[1];
        } else if (match = /^"(.*)"$/.exec(key)) {
          return match[1];
        } else if (match = /^(\d+)$/.exec(key)) {
          return Number(match[1]);
        } else if (match = /^\((\S+)\.\.(\S+)\)$/.exec(key)) {
          lo = Number(resolve(match[1]));
          return hi = Number(resolve(match[2]));
        } else if (match = /^(\d[\d\.]+)$/.exec(key)) {
          return Number(match[1]);
        } else {
          return this.variable(key);
        }
      }
    };

    Context.prototype.findVariable = function(key) {
      var scope, variable,
        _this = this;
      scope = _(this.scopes).detect(function(s) {
        return typeof s.hasOwnProperty === "function" ? s.hasOwnProperty(key) : void 0;
      });
      variable = null;
      scope || (scope = _(this.environments).detect(function(e) {
        return variable = _this.lookupAndEvaluate(e, key);
      }));
      scope || (scope = this.environments[this.environments.length - 1] || this.scopes[this.scopes.length - 1]);
      variable || (variable = this.lookupAndEvaluate(scope, key));
      return Q.when(variable).then(function(variable) {
        return _this.liquify(variable);
      });
    };

    Context.prototype.variable = function(markup) {
      var _this = this;
      return Liquid.async.promise(function(future) {
        var firstPart, iterator, mapper, match, object, parts, squareBracketed;
        parts = Liquid.Helpers.scan(markup, Liquid.VariableParser);
        squareBracketed = /^\[(.*)\]$/;
        firstPart = parts.shift();
        if (match = squareBracketed.exec(firstPart)) {
          firstPart = match[1];
        }
        object = _this.findVariable(firstPart);
        if (parts.length === 0) {
          return future.resolve(object);
        }
        mapper = function(part, next) {
          if (object === null) {
            return next();
          }
          return Q.when(object).done(function(_object) {
            var bracketMatch;
            object = _this.liquify(_object);
            if (object === null) {
              return next();
            }
            bracketMatch = squareBracketed.exec(part);
            if (bracketMatch) {
              part = _this.resolve(bracketMatch[1]);
            }
            return Q.when(part).done(function(part) {
              var isArrayAccess, isObjectAccess, isSpecialAccess;
              isArrayAccess = _.isArray(object) && _.isNumber(part);
              isObjectAccess = _.isObject(object) && (part in object);
              if (isArrayAccess || isObjectAccess) {
                return Q.when(_this.lookupAndEvaluate(object, part)).done(function(result) {
                  object = _this.liquify(result);
                  return next();
                });
              } else {
                isSpecialAccess = !bracketMatch && object && (_.isArray(object) || _.isString(object)) && ["size", "first", "last"].indexOf(part) >= 0;
                if (isSpecialAccess) {
                  object = (function() {
                    switch (part) {
                      case "size":
                        return this.liquify(object.length);
                      case "first":
                        return this.liquify(object[0]);
                      case "last":
                        return this.liquify(object[object.length - 1]);
                      default:
                        return this.liquify(object);
                    }
                  }).call(_this);
                  return next();
                } else {
                  object = null;
                  return next();
                }
              }
            });
          });
        };
        iterator = function(index) {
          try {
            return mapper(parts[index], function(err) {
              index += 1;
              if (index < parts.length) {
                return iterator(index);
              } else {
                return future.resolve(object);
              }
            });
          } catch (e) {
            console.log("Couldn't walk variable: " + markup);
            return future.reject(e);
          }
        };
        return iterator(0);
      });
    };

    Context.prototype.lookupAndEvaluate = function(obj, key) {
      var value;
      value = obj[key];
      if (_.isFunction(value)) {
        return obj[key] = value.length === 0 ? value.call(obj) : value.call(obj, this);
      } else {
        return value;
      }
    };

    Context.prototype.squashInstanceAssignsWithEnvironments = function() {
      var lastScope,
        _this = this;
      lastScope = this.lastScope();
      return _(lastScope).chain().keys().forEach(function(key) {
        return _(_this.environments).detect(function(env) {
          if (_(env).keys().indexOf(key) >= 0) {
            lastScope[key] = _this.lookupAndEvaluate(env, key);
            return true;
          }
        });
      });
    };

    Context.prototype.liquify = function(object) {
      if (object == null) {
        return object;
      }
      if (typeof object.toLiquid === "function") {
        object = object.toLiquid();
      } else {
        true;
      }
      if (object instanceof Liquid.Drop) {
        object.context = this;
      }
      return object;
    };

    return Context;

  })();

}).call(this);
